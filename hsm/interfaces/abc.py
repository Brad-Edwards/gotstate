from typing import Any, Dict, List, Optional, Protocol

from hsm.interfaces.types import EventID, StateID, ValidationResult


class AbstractStateMachine(Protocol):
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def reset(self) -> None: ...
    def process_event(self, event: "AbstractEvent") -> None: ...
    def get_current_state_id(self) -> StateID: ...


class AbstractState(Protocol):
    def on_enter(self) -> None: ...
    def on_exit(self) -> None: ...
    @property
    def data(self) -> Dict[str, Any]: ...
    def get_id(self) -> StateID: ...


class AbstractCompositeState(AbstractState, Protocol):
    def get_substates(self) -> List["AbstractState"]: ...
    def get_initial_state(self) -> "AbstractState": ...
    def has_history(self) -> bool: ...


class AbstractEvent(Protocol):
    def get_id(self) -> EventID: ...
    def get_payload(self) -> Any: ...
    def get_priority(self) -> int: ...


class AbstractGuard(Protocol):
    def check(self, event: "AbstractEvent", state_data: Any) -> bool: ...


class AbstractAction(Protocol):
    def execute(self, event: "AbstractEvent", state_data: Any) -> None: ...


class AbstractHook(Protocol):
    def on_enter(self, state_id: StateID) -> None: ...
    def on_exit(self, state_id: StateID) -> None: ...
    def pre_transition(self, transition: "AbstractTransition") -> None: ...
    def post_transition(self, transition: "AbstractTransition") -> None: ...


class AbstractTransition(Protocol):
    def get_source_state_id(self) -> StateID: ...
    def get_target_state_id(self) -> StateID: ...
    def get_guard(self) -> Optional[AbstractGuard]: ...
    def get_actions(self) -> List[AbstractAction]: ...
    def get_priority(self) -> int: ...


class AbstractValidator(Protocol):
    def validate_structure(self) -> List[ValidationResult]: ...
    def validate_behavior(self) -> List[ValidationResult]: ...
    def validate_data(self) -> List[ValidationResult]: ...


class AbstractEventQueue(Protocol):
    def enqueue(self, event: "AbstractEvent") -> None: ...
    def dequeue(self) -> "AbstractEvent": ...
    def is_full(self) -> bool: ...
    def is_empty(self) -> bool: ...


class AbstractTimer(Protocol):
    def schedule_timeout(self, duration: float, event: "AbstractEvent") -> None: ...
    def cancel_timeout(self, event_id: EventID) -> None: ...
